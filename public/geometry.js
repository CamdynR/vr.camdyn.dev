!function(){let c=new THREE.Matrix4,d=new THREE.Object3D,e=new THREE.Vector3;class a extends THREE.EventDispatcher{constructor(){super(),this.uuid=THREE.MathUtils.generateUUID(),this.name="",this.type="Geometry",this.vertices=[],this.colors=[],this.faces=[],this.faceVertexUvs=[[]],this.morphTargets=[],this.morphNormals=[],this.skinWeights=[],this.skinIndices=[],this.lineDistances=[],this.boundingBox=null,this.boundingSphere=null,this.elementsNeedUpdate=!1,this.verticesNeedUpdate=!1,this.uvsNeedUpdate=!1,this.normalsNeedUpdate=!1,this.colorsNeedUpdate=!1,this.lineDistancesNeedUpdate=!1,this.groupsNeedUpdate=!1}applyMatrix4(e){let f=new THREE.Matrix3().getNormalMatrix(e);for(let a=0,g=this.vertices.length;a<g;a++){let h=this.vertices[a];h.applyMatrix4(e)}for(let b=0,i=this.faces.length;b<i;b++){let c=this.faces[b];c.normal.applyMatrix3(f).normalize();for(let d=0,j=c.vertexNormals.length;d<j;d++)c.vertexNormals[d].applyMatrix3(f).normalize()}return null!==this.boundingBox&&this.computeBoundingBox(),null!==this.boundingSphere&&this.computeBoundingSphere(),this.verticesNeedUpdate=!0,this.normalsNeedUpdate=!0,this}rotateX(a){return c.makeRotationX(a),this.applyMatrix4(c),this}rotateY(a){return c.makeRotationY(a),this.applyMatrix4(c),this}rotateZ(a){return c.makeRotationZ(a),this.applyMatrix4(c),this}translate(a,b,d){return c.makeTranslation(a,b,d),this.applyMatrix4(c),this}scale(a,b,d){return c.makeScale(a,b,d),this.applyMatrix4(c),this}lookAt(a){return d.lookAt(a),d.updateMatrix(),this.applyMatrix4(d.matrix),this}fromBufferGeometry(c){let n=this,a=null!==c.index?c.index:void 0,e=c.attributes;if(void 0===e.position)return console.error("THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion."),this;let k=e.position,t=e.normal,o=e.color,u=e.uv,q=e.uv2;void 0!==q&&(this.faceVertexUvs[1]=[]);for(let h=0;h<k.count;h++)n.vertices.push(new THREE.Vector3().fromBufferAttribute(k,h)),void 0!==o&&n.colors.push(new THREE.Color().fromBufferAttribute(o,h));function i(a,c,d,e){let f=void 0===o?[]:[n.colors[a].clone(),n.colors[c].clone(),n.colors[d].clone()],g=void 0===t?[]:[new THREE.Vector3().fromBufferAttribute(t,a),new THREE.Vector3().fromBufferAttribute(t,c),new THREE.Vector3().fromBufferAttribute(t,d)],h=new b(a,c,d,g,f,e);n.faces.push(h),void 0!==u&&n.faceVertexUvs[0].push([new THREE.Vector2().fromBufferAttribute(u,a),new THREE.Vector2().fromBufferAttribute(u,c),new THREE.Vector2().fromBufferAttribute(u,d)]),void 0!==q&&n.faceVertexUvs[1].push([new THREE.Vector2().fromBufferAttribute(q,a),new THREE.Vector2().fromBufferAttribute(q,c),new THREE.Vector2().fromBufferAttribute(q,d)])}let l=c.groups;if(l.length>0)for(let m=0;m<l.length;m++){let j=l[m],p=j.start,r=j.count;for(let d=p,s=p+r;d<s;d+=3)void 0!==a?i(a.getX(d),a.getX(d+1),a.getX(d+2),j.materialIndex):i(d,d+1,d+2,j.materialIndex)}else if(void 0!==a)for(let f=0;f<a.count;f+=3)i(a.getX(f),a.getX(f+1),a.getX(f+2));else for(let g=0;g<k.count;g+=3)i(g,g+1,g+2);return this.computeFaceNormals(),null!==c.boundingBox&&(this.boundingBox=c.boundingBox.clone()),null!==c.boundingSphere&&(this.boundingSphere=c.boundingSphere.clone()),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(e).negate(),this.translate(e.x,e.y,e.z),this}normalize(){this.computeBoundingSphere();let b=this.boundingSphere.center,c=this.boundingSphere.radius,a=0===c?1:1/c,d=new THREE.Matrix4;return d.set(a,0,0,-a*b.x,0,a,0,-a*b.y,0,0,a,-a*b.z,0,0,0,1),this.applyMatrix4(d),this}computeFaceNormals(){let a=new THREE.Vector3,d=new THREE.Vector3;for(let c=0,f=this.faces.length;c<f;c++){let b=this.faces[c],g=this.vertices[b.a],e=this.vertices[b.b],h=this.vertices[b.c];a.subVectors(h,e),d.subVectors(g,e),a.cross(d),a.normalize(),b.normal.copy(a)}}computeVertexNormals(n=!0){let a=new Array(this.vertices.length);for(let g=0,o=this.vertices.length;g<o;g++)a[g]=new THREE.Vector3;if(n){let f=new THREE.Vector3,l=new THREE.Vector3;for(let h=0,p=this.faces.length;h<p;h++){let d=this.faces[h],q=this.vertices[d.a],m=this.vertices[d.b],r=this.vertices[d.c];f.subVectors(r,m),l.subVectors(q,m),f.cross(l),a[d.a].add(f),a[d.b].add(f),a[d.c].add(f)}}else{this.computeFaceNormals();for(let i=0,s=this.faces.length;i<s;i++){let e=this.faces[i];a[e.a].add(e.normal),a[e.b].add(e.normal),a[e.c].add(e.normal)}}for(let j=0,t=this.vertices.length;j<t;j++)a[j].normalize();for(let k=0,u=this.faces.length;k<u;k++){let b=this.faces[k],c=b.vertexNormals;3===c.length?(c[0].copy(a[b.a]),c[1].copy(a[b.b]),c[2].copy(a[b.c])):(c[0]=a[b.a].clone(),c[1]=a[b.b].clone(),c[2]=a[b.c].clone())}this.faces.length>0&&(this.normalsNeedUpdate=!0)}computeFlatVertexNormals(){this.computeFaceNormals();for(let c=0,d=this.faces.length;c<d;c++){let a=this.faces[c],b=a.vertexNormals;3===b.length?(b[0].copy(a.normal),b[1].copy(a.normal),b[2].copy(a.normal)):(b[0]=a.normal.clone(),b[1]=a.normal.clone(),b[2]=a.normal.clone())}this.faces.length>0&&(this.normalsNeedUpdate=!0)}computeMorphNormals(){for(let i=0,n=this.faces.length;i<n;i++){let b=this.faces[i];b.__originalFaceNormal?b.__originalFaceNormal.copy(b.normal):b.__originalFaceNormal=b.normal.clone(),b.__originalVertexNormals||(b.__originalVertexNormals=[]);for(let d=0,o=b.vertexNormals.length;d<o;d++)b.__originalVertexNormals[d]?b.__originalVertexNormals[d].copy(b.vertexNormals[d]):b.__originalVertexNormals[d]=b.vertexNormals[d].clone()}let f=new a;f.faces=this.faces;for(let c=0,p=this.morphTargets.length;c<p;c++){if(!this.morphNormals[c]){this.morphNormals[c]={},this.morphNormals[c].faceNormals=[],this.morphNormals[c].vertexNormals=[];let q=this.morphNormals[c].faceNormals,r=this.morphNormals[c].vertexNormals;for(let l=0,s=this.faces.length;l<s;l++){let t=new THREE.Vector3,u={a:new THREE.Vector3,b:new THREE.Vector3,c:new THREE.Vector3};q.push(t),r.push(u)}}let m=this.morphNormals[c];f.vertices=this.morphTargets[c].vertices,f.computeFaceNormals(),f.computeVertexNormals();for(let e=0,v=this.faces.length;e<v;e++){let g=this.faces[e],w=m.faceNormals[e],j=m.vertexNormals[e];w.copy(g.normal),j.a.copy(g.vertexNormals[0]),j.b.copy(g.vertexNormals[1]),j.c.copy(g.vertexNormals[2])}}for(let k=0,x=this.faces.length;k<x;k++){let h=this.faces[k];h.normal=h.__originalFaceNormal,h.vertexNormals=h.__originalVertexNormals}}computeBoundingBox(){null===this.boundingBox&&(this.boundingBox=new THREE.Box3),this.boundingBox.setFromPoints(this.vertices)}computeBoundingSphere(){null===this.boundingSphere&&(this.boundingSphere=new THREE.Sphere),this.boundingSphere.setFromPoints(this.vertices)}merge(a,g,A=0){if(!(a&&a.isGeometry)){console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.",a);return}let f,h=this.vertices.length,B=this.vertices,q=a.vertices,C=this.faces,r=a.faces,D=this.colors,s=a.colors;void 0!==g&&(f=new THREE.Matrix3().getNormalMatrix(g));for(let i=0,E=q.length;i<E;i++){let F=q[i],t=F.clone();void 0!==g&&t.applyMatrix4(g),B.push(t)}for(let j=0,G=s.length;j<G;j++)D.push(s[j].clone());for(let k=0,H=r.length;k<H;k++){let c=r[k],l,u,v=c.vertexNormals,w=c.vertexColors,d=new b(c.a+h,c.b+h,c.c+h);d.normal.copy(c.normal),void 0!==f&&d.normal.applyMatrix3(f).normalize();for(let m=0,I=v.length;m<I;m++)l=v[m].clone(),void 0!==f&&l.applyMatrix3(f).normalize(),d.vertexNormals.push(l);d.color.copy(c.color);for(let n=0,J=w.length;n<J;n++)u=w[n],d.vertexColors.push(u.clone());d.materialIndex=c.materialIndex+A,C.push(d)}for(let e=0,K=a.faceVertexUvs.length;e<K;e++){let x=a.faceVertexUvs[e];void 0===this.faceVertexUvs[e]&&(this.faceVertexUvs[e]=[]);for(let o=0,L=x.length;o<L;o++){let y=x[o],z=[];for(let p=0,M=y.length;p<M;p++)z.push(y[p].clone());this.faceVertexUvs[e].push(z)}}}mergeMesh(a){if(!(a&&a.isMesh)){console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.",a);return}a.matrixAutoUpdate&&a.updateMatrix(),this.merge(a.geometry,a.matrix)}mergeVertices(p=4){let g={},d=[],c=[],h=Math.pow(10,p);for(let b=0,q=this.vertices.length;b<q;b++){let i=this.vertices[b],j=Math.round(i.x*h)+"_"+Math.round(i.y*h)+"_"+Math.round(i.z*h);void 0===g[j]?(g[j]=b,d.push(this.vertices[b]),c[b]=d.length-1):c[b]=c[g[j]]}let k=[];for(let e=0,r=this.faces.length;e<r;e++){let a=this.faces[e];a.a=c[a.a],a.b=c[a.b],a.c=c[a.c];let n=[a.a,a.b,a.c];for(let f=0;f<3;f++)if(n[f]===n[(f+1)%3]){k.push(e);break}}for(let l=k.length-1;l>=0;l--){let o=k[l];this.faces.splice(o,1);for(let m=0,s=this.faceVertexUvs.length;m<s;m++)this.faceVertexUvs[m].splice(o,1)}let t=this.vertices.length-d.length;return this.vertices=d,t}setFromPoints(c){this.vertices=[];for(let a=0,d=c.length;a<d;a++){let b=c[a];this.vertices.push(new THREE.Vector3(b.x,b.y,b.z||0))}return this}sortFacesByMaterialIndex(){let c=this.faces,d=c.length;for(let e=0;e<d;e++)c[e]._id=e;c.sort(function(a,b){return a.materialIndex-b.materialIndex});let f=this.faceVertexUvs[0],g=this.faceVertexUvs[1],a,b;f&&f.length===d&&(a=[]),g&&g.length===d&&(b=[]);for(let h=0;h<d;h++){let i=c[h]._id;a&&a.push(f[i]),b&&b.push(g[i])}a&&(this.faceVertexUvs[0]=a),b&&(this.faceVertexUvs[1]=b)}toJSON(){let c={metadata:{version:4.5,type:"Geometry",generator:"Geometry.toJSON"}};if(c.uuid=this.uuid,c.type=this.type,""!==this.name&&(c.name=this.name),void 0!==this.parameters){let f=this.parameters;for(let g in f)void 0!==f[g]&&(c[g]=f[g]);return c}let m=[];for(let h=0;h<this.vertices.length;h++){let i=this.vertices[h];m.push(i.x,i.y,i.z)}let d=[],u=[],x={},n=[],y={},o=[],z={};for(let e=0;e<this.faces.length;e++){let b=this.faces[e],v=!0,w=!1,p=void 0!==this.faceVertexUvs[0][e],q=b.normal.length()>0,r=b.vertexNormals.length>0,s=1!==b.color.r||1!==b.color.g||1!==b.color.b,t=b.vertexColors.length>0,a=0;if(a=A(a,0,0),a=A(a,1,v),a=A(a,2,w),a=A(a,3,p),a=A(a,4,q),a=A(a,5,r),a=A(a,6,s),a=A(a,7,t),d.push(a),d.push(b.a,b.b,b.c),d.push(b.materialIndex),p){let j=this.faceVertexUvs[0][e];d.push(D(j[0]),D(j[1]),D(j[2]))}if(q&&d.push(B(b.normal)),r){let k=b.vertexNormals;d.push(B(k[0]),B(k[1]),B(k[2]))}if(s&&d.push(C(b.color)),t){let l=b.vertexColors;d.push(C(l[0]),C(l[1]),C(l[2]))}}function A(a,b,c){return c?a|1<<b:a& ~(1<<b)}function B(a){let b=a.x.toString()+a.y.toString()+a.z.toString();return void 0!==x[b]||(x[b]=u.length/3,u.push(a.x,a.y,a.z)),x[b]}function C(a){let b=a.r.toString()+a.g.toString()+a.b.toString();return void 0!==y[b]||(y[b]=n.length,n.push(a.getHex())),y[b]}function D(a){let b=a.x.toString()+a.y.toString();return void 0!==z[b]||(z[b]=o.length/2,o.push(a.x,a.y)),z[b]}return c.data={},c.data.vertices=m,c.data.normals=u,n.length>0&&(c.data.colors=n),o.length>0&&(c.data.uvs=[o]),c.data.faces=d,c}clone(){return new a().copy(this)}copy(a){this.vertices=[],this.colors=[],this.faces=[],this.faceVertexUvs=[[]],this.morphTargets=[],this.morphNormals=[],this.skinWeights=[],this.skinIndices=[],this.lineDistances=[],this.boundingBox=null,this.boundingSphere=null,this.name=a.name;let w=a.vertices;for(let j=0,H=w.length;j<H;j++)this.vertices.push(w[j].clone());let x=a.colors;for(let k=0,I=x.length;k<I;k++)this.colors.push(x[k].clone());let y=a.faces;for(let l=0,J=y.length;l<J;l++)this.faces.push(y[l].clone());for(let f=0,K=a.faceVertexUvs.length;f<K;f++){let z=a.faceVertexUvs[f];void 0===this.faceVertexUvs[f]&&(this.faceVertexUvs[f]=[]);for(let m=0,L=z.length;m<L;m++){let A=z[m],B=[];for(let n=0,M=A.length;n<M;n++){let N=A[n];B.push(N.clone())}this.faceVertexUvs[f].push(B)}}let c=a.morphTargets;for(let b=0,O=c.length;b<O;b++){let g={};if(g.name=c[b].name,void 0!==c[b].vertices){g.vertices=[];for(let o=0,P=c[b].vertices.length;o<P;o++)g.vertices.push(c[b].vertices[o].clone())}if(void 0!==c[b].normals){g.normals=[];for(let p=0,Q=c[b].normals.length;p<Q;p++)g.normals.push(c[b].normals[p].clone())}this.morphTargets.push(g)}let e=a.morphNormals;for(let d=0,R=e.length;d<R;d++){let h={};if(void 0!==e[d].vertexNormals){h.vertexNormals=[];for(let q=0,S=e[d].vertexNormals.length;q<S;q++){let r=e[d].vertexNormals[q],i={};i.a=r.a.clone(),i.b=r.b.clone(),i.c=r.c.clone(),h.vertexNormals.push(i)}}if(void 0!==e[d].faceNormals){h.faceNormals=[];for(let s=0,T=e[d].faceNormals.length;s<T;s++)h.faceNormals.push(e[d].faceNormals[s].clone())}this.morphNormals.push(h)}let C=a.skinWeights;for(let t=0,U=C.length;t<U;t++)this.skinWeights.push(C[t].clone());let D=a.skinIndices;for(let u=0,V=D.length;u<V;u++)this.skinIndices.push(D[u].clone());let E=a.lineDistances;for(let v=0,W=E.length;v<W;v++)this.lineDistances.push(E[v]);let F=a.boundingBox;null!==F&&(this.boundingBox=F.clone());let G=a.boundingSphere;return null!==G&&(this.boundingSphere=G.clone()),this.elementsNeedUpdate=a.elementsNeedUpdate,this.verticesNeedUpdate=a.verticesNeedUpdate,this.uvsNeedUpdate=a.uvsNeedUpdate,this.normalsNeedUpdate=a.normalsNeedUpdate,this.colorsNeedUpdate=a.colorsNeedUpdate,this.lineDistancesNeedUpdate=a.lineDistancesNeedUpdate,this.groupsNeedUpdate=a.groupsNeedUpdate,this}toBufferGeometry(){let a=new f().fromGeometry(this),b=new THREE.BufferGeometry,j=new Float32Array(3*a.vertices.length);if(b.setAttribute("position",new THREE.BufferAttribute(j,3).copyVector3sArray(a.vertices)),a.normals.length>0){let k=new Float32Array(3*a.normals.length);b.setAttribute("normal",new THREE.BufferAttribute(k,3).copyVector3sArray(a.normals))}if(a.colors.length>0){let l=new Float32Array(3*a.colors.length);b.setAttribute("color",new THREE.BufferAttribute(l,3).copyColorsArray(a.colors))}if(a.uvs.length>0){let m=new Float32Array(2*a.uvs.length);b.setAttribute("uv",new THREE.BufferAttribute(m,2).copyVector2sArray(a.uvs))}if(a.uvs2.length>0){let n=new Float32Array(2*a.uvs2.length);b.setAttribute("uv2",new THREE.BufferAttribute(n,2).copyVector2sArray(a.uvs2))}for(let e in b.groups=a.groups,a.morphTargets){let g=[],h=a.morphTargets[e];for(let c=0,o=h.length;c<o;c++){let d=h[c],i=new THREE.Float32BufferAttribute(3*d.data.length,3);i.name=d.name,g.push(i.copyVector3sArray(d.data))}b.morphAttributes[e]=g}if(a.skinIndices.length>0){let p=new THREE.Float32BufferAttribute(4*a.skinIndices.length,4);b.setAttribute("skinIndex",p.copyVector4sArray(a.skinIndices))}if(a.skinWeights.length>0){let q=new THREE.Float32BufferAttribute(4*a.skinWeights.length,4);b.setAttribute("skinWeight",q.copyVector4sArray(a.skinWeights))}return null!==a.boundingSphere&&(b.boundingSphere=a.boundingSphere.clone()),null!==a.boundingBox&&(b.boundingBox=a.boundingBox.clone()),b}computeTangents(){console.error("THREE.Geometry: .computeTangents() has been removed.")}computeLineDistances(){console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.")}applyMatrix(a){return console.warn("THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(a)}dispose(){this.dispatchEvent({type:"dispose"})}static createBufferGeometryFromObject(c){let b=new THREE.BufferGeometry,a=c.geometry;if(c.isPoints||c.isLine){let d=new THREE.Float32BufferAttribute(3*a.vertices.length,3),e=new THREE.Float32BufferAttribute(3*a.colors.length,3);if(b.setAttribute("position",d.copyVector3sArray(a.vertices)),b.setAttribute("color",e.copyColorsArray(a.colors)),a.lineDistances&&a.lineDistances.length===a.vertices.length){let f=new THREE.Float32BufferAttribute(a.lineDistances.length,1);b.setAttribute("lineDistance",f.copyArray(a.lineDistances))}null!==a.boundingSphere&&(b.boundingSphere=a.boundingSphere.clone()),null!==a.boundingBox&&(b.boundingBox=a.boundingBox.clone())}else c.isMesh&&(b=a.toBufferGeometry());return b}}a.prototype.isGeometry=!0;class f{constructor(){this.vertices=[],this.normals=[],this.colors=[],this.uvs=[],this.uvs2=[],this.groups=[],this.morphTargets={},this.skinWeights=[],this.skinIndices=[],this.boundingBox=null,this.boundingSphere=null,this.verticesNeedUpdate=!1,this.normalsNeedUpdate=!1,this.colorsNeedUpdate=!1,this.uvsNeedUpdate=!1,this.groupsNeedUpdate=!1}computeGroups(g){let c=[],a,b,d,e=g.faces;for(b=0;b<e.length;b++){let f=e[b];f.materialIndex!==d&&(d=f.materialIndex,void 0!==a&&(a.count=3*b-a.start,c.push(a)),a={start:3*b,materialIndex:d})}void 0!==a&&(a.count=3*b-a.start,c.push(a)),this.groups=c}fromGeometry(a){let r=a.faces,d=a.vertices,e=a.faceVertexUvs,A=e[0]&&e[0].length>0,B=e[1]&&e[1].length>0,s=a.morphTargets,t=s.length,f;if(t>0){f=[];for(let g=0;g<t;g++)f[g]={name:s[g].name,data:[]};this.morphTargets.position=f}let u=a.morphNormals,v=u.length,h;if(v>0){h=[];for(let i=0;i<v;i++)h[i]={name:u[i].name,data:[]};this.morphTargets.normal=h}let j=a.skinIndices,k=a.skinWeights,C=j.length===d.length,D=k.length===d.length;d.length>0&&0===r.length&&console.error("THREE.DirectGeometry: Faceless geometries are not supported.");for(let c=0;c<r.length;c++){let b=r[c];this.vertices.push(d[b.a],d[b.b],d[b.c]);let l=b.vertexNormals;if(3===l.length)this.normals.push(l[0],l[1],l[2]);else{let w=b.normal;this.normals.push(w,w,w)}let m=b.vertexColors;if(3===m.length)this.colors.push(m[0],m[1],m[2]);else{let x=b.color;this.colors.push(x,x,x)}if(!0===A){let n=e[0][c];void 0!==n?this.uvs.push(n[0],n[1],n[2]):(console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ",c),this.uvs.push(new THREE.Vector2,new THREE.Vector2,new THREE.Vector2))}if(!0===B){let o=e[1][c];void 0!==o?this.uvs2.push(o[0],o[1],o[2]):(console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ",c),this.uvs2.push(new THREE.Vector2,new THREE.Vector2,new THREE.Vector2))}for(let p=0;p<t;p++){let y=s[p].vertices;f[p].data.push(y[b.a],y[b.b],y[b.c])}for(let q=0;q<v;q++){let z=u[q].vertexNormals[c];h[q].data.push(z.a,z.b,z.c)}C&&this.skinIndices.push(j[b.a],j[b.b],j[b.c]),D&&this.skinWeights.push(k[b.a],k[b.b],k[b.c])}return this.computeGroups(a),this.verticesNeedUpdate=a.verticesNeedUpdate,this.normalsNeedUpdate=a.normalsNeedUpdate,this.colorsNeedUpdate=a.colorsNeedUpdate,this.uvsNeedUpdate=a.uvsNeedUpdate,this.groupsNeedUpdate=a.groupsNeedUpdate,null!==a.boundingSphere&&(this.boundingSphere=a.boundingSphere.clone()),null!==a.boundingBox&&(this.boundingBox=a.boundingBox.clone()),this}}class b{constructor(c,d,e,a,b,f=0){this.a=c,this.b=d,this.c=e,this.normal=a&&a.isVector3?a:new THREE.Vector3,this.vertexNormals=Array.isArray(a)?a:[],this.color=b&&b.isColor?b:new THREE.Color,this.vertexColors=Array.isArray(b)?b:[],this.materialIndex=f}clone(){return new this.constructor().copy(this)}copy(a){this.a=a.a,this.b=a.b,this.c=a.c,this.normal.copy(a.normal),this.color.copy(a.color),this.materialIndex=a.materialIndex;for(let b=0,d=a.vertexNormals.length;b<d;b++)this.vertexNormals[b]=a.vertexNormals[b].clone();for(let c=0,e=a.vertexColors.length;c<e;c++)this.vertexColors[c]=a.vertexColors[c].clone();return this}}THREE.Face3=b,THREE.Geometry=a}()